# Why hypeReduce

**A new (simpler) way**

HypeReduce combines functional principles with the dynamic power of javascript. 
The result is a programming style that makes the world a much simpler place. 

All actions are dispatched to a *Dynamic State Object*.
Where you would normally find static values, these have been replaced with 
*Dynamic-Nodes* that are able to respond to actions.

Parts of the updated state are then emitted to an application through connections, 
ensuring that parts of an application only recieve what it needs - when it needs it.

So all actions are dispatched to Dynamic State and then fanned out to connections:

```

                              --> connect()
                            --> connect()
actions --> Dynamic-State --> connect()
                            --> connect()
                              --> connect()

```

**Purity**

HypReduce applications are able to be built from 2 types of functions.
1. Pure Functions
2. Flow Based Functions

**Pure functions** can only utilise the inputs provided to the function, along with 
any other pure functions.

- Given the same set of inputs Pure functions must always return the same result.
- They can't return a void.
- They cannot mutate anything, including the inputs.

The simplest pure function is one that takes no arguments and always produces the same result.

`const a = () => 3`
These are basically constants, and for that reason we can also use constants in a pure function.

We can also use pseudo-pure functions in place of pure functions to handle impurity. 
The easiest example is the `display` function in hypeReduce. It takes an input and 
simply returns the input as a response. It satisfies all the requirements of being pure as far as 
a function using it is concerned. However under the hood, it is actually logging to the console 
which is an impure operation. We use `display` instead of `console.log` directly because `console.log`
is definitely impure. For a start it doesn’t return a response - just a void. Secondly it reaches 
outside of our function and into the console to print something. `display` adds an abstraction around that.

Anything outside of this is handled by the flow api, using Flow Based Functions

**Flow Based Functions** allow a flow to be passed through a sequence of operations.
The sequence abstracts away the need to use impure functions.

**Safety**

HypeReduce is built from scratch with TypeScript, and has type safety at ❤️

```typescript

// Dynamic Nodes are type safe and know that the type of the initial value should
// always be the same as an action's return value.
// You can also be explicit in what type a Dynamic Node's value is too...

manageState({
  counter: d<number>({
    connects: ['counter'],
    init: 1,
    actions: {
      INC
    }
  })
})

// We can then add type information to the connection to coerce the emitted value
// into being treated explicity as a particular type.

connect<number>('counter', value => doStuff(value))

```